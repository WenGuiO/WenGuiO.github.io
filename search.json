[{"title":"博客搭建(白嫖篇)","path":"/2023/02/08/博客搭建(白嫖篇)/","content":"小白、非本专业者教程–不管是哪个行业，都可以拥有一个属于自己的博客或网站，我们可以在自己的空间内自由发挥。本篇文章将通过Hexo与Gitee Page来讲解如何免费的搭建自己的小网站。 搭建说明Node.js 配置Hexo 框架的配置与使用说明Git 配置与部署使用VS Code 便捷管理Gitee page 的部署","tags":["博客"],"categories":["博客搭建"]},{"title":"Ubuntu知识记录","path":"/2023/01/16/Ubuntu知识记录/","content":"赋予普通用户管理员权限编辑&#x2F;etc&#x2F;passwd文件 1vim /etc/passwd 找到需要更改权限的用户名，如: 12root:x:0:0:root:/root:/bin/bashubuntu:x:500:500:ubuntu:/home/ubuntu:/bin/bash（刚刚创建的用户为1000） 将普通用户改为超级管理员将1000更改为0,将管理员升级为超级管理员将500 更改为0。","tags":["Linux"],"categories":["Linux"]},{"title":"MarkDown基础语法教程","path":"/2023/01/10/MarkDown基础语法教程/","content":"MarkDown基础语法教程–小白入门，总结简单，日常浏览学习，轻松上手。 1. 标题标题共分6级，以 # 个数来确认 1.1 常用语法在一行的开头放 # 加空格再加标题内容。 1234# 标题名字（一级）## 标题名字（二级）...###### 标题名字 （六级） 1.2 可选语法标题内容的后面如果也存在空格和 #，也可以构成标题，且标题的级别以前面 # 的数量为准 Markdown 预览 # 标题 1 ## 标题 1 ## 标题 2 ## 标题 2 另外，一级标题 和二级标题 也可以用下列形式表示。 1234567一级标题: 标题1 ===\t二级标题: 标题2 --- 等号和减号的数量不限制，可以有一个或多个。 2.文字2.1 删除线输入以下代码 1这是 ~~删除线~~ 结果：这就是 删除线 2.2 斜体1这是 *斜体* 结果：这是 斜体 2.3 加粗1这是 **加粗** 结果：这是 加粗 2.4 斜体+加粗1这是 ***斜体+加粗*** 结果：这是 斜体+加粗_ 3. 表情符Emoji 支持表情符号，可以用系统默认的 Emoji 符号。 也可以用图片的表情，输入 : 将会出现智能提示。 123:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile: :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary::+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger: :smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile: :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger: 4. 表格4.1 语法使用| 分隔不同的单元格，使用 -（至少3个） 来分隔表头和其他行： 1234id | name |--- | --- |1 | 张三 |2 | 李四 | 为使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格）。 id name 1 张三 2 李四 4.2 对齐方式左侧添加一个冒号表示左对齐，右侧添加一个冒号表示右对齐，左右各添加一个冒号表示居中对齐： 1234| 左对齐 | 右对齐 | 居中 || :--- | ---: | :---: || 刺客伍六七 | 刺客伍六七 | 刺客伍六七 || 梅花十三 | 梅花十三 | 梅花十三 | 左对齐 右对齐 居中 刺客伍六七 刺客伍六七 刺客伍六七 梅花十三 梅花十三 梅花十三 5. 引用使用大于号 &gt; 和空格生成引用 1&gt;GuiGe GuiGe 引用嵌套 12&gt; 我是引用&gt;&gt; 我是引用中的引用 我是引用 我是引用中的引用 6. 列表6.1 无序列表在文本前面加减号(-)、星号(*)、加号(+)实现。 123* 张三+ 李四- 王五 张三 李四 王五 6.2 有序列表在文本前面添加数字加点加空格可以构成有序列表。最终生成的列表前面的编号和前面的数字没有绝对关系，总是从第一个数字开始依次增加。 1231. 有序列表是以数字和`.` 加空格开始；2. 数字的序列并不会影响生成的列表序列；4. 序号是4，生成是3。 有序列表是以数字和 . 加空格开始； 数字的序列并不会影响生成的列表序列； 序号是4，生成是3。 可以使用：数字\\. 来取消显示为列表（用反斜杠进行转义） 7. 代码7.1 代码块1​```语言名称 12public static void main(String[] args) &#123; &#125; 7.2 行内代码通过 ` + 代码内容 + `， 效果： 代码内容 8. 分隔线在一行中使用三个或更多的 *、- 或 _ 来添加分隔线：效果如下： 展示的分隔符 9.跳转格式： [跳转名称](网址)。 9.1 外部跳转1234[主页](http://wengui.work)有文字提示的链接[GuiGe](http://wengui.work/about/ GuiGe介绍) 主页 [GuiGe](http://wengui.work/about/ 关于GuiGe) 9.2 内部跳转格式为 [跳转名称](#要去的目的地--标题）。 1去[1. 标题 ](#1. 标题) 去[1. 标题 ](#1. 标题) 9.3 自动链接使用 &lt;&gt; 包括的 URL 或邮箱地址会被自动转换为超链接： 12&lt;http://wengui.work&gt;&lt;768476667@qq.com&gt; http://wengui.work&#x37;&#x36;&#x38;&#52;&#55;&#54;&#x36;&#54;&#55;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109; 10. 图片1![图片](图片网址/图片本地存储的路径) 如： 1![friedChicken](https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg) 11. 脚注脚注类似于参考文献或补充说明，统一出现的文档的最后，可在文中任意位置引用。脚注的定义语法为： [^名称]: 内容脚注的引用语法为：[^名称]。 11.1 行内脚注 行内脚注是可选功能，并非所有支持脚注的解析器都支持行内脚注。 行内脚注 ^[行内脚注] 不需要显式声明，只要在需要脚注的地方直接使用就可以，解析器会把内容提取出来放到文末。 如：打工人 [^1][^1]: 指对所有从事体力劳动或者技术劳动的人的统称，无论是农民工，还是白领，又或者是中层领导、创业者，都可以自称“打工人”。“打工人”有着一系列显著的特征，比如对现实都有着清醒的认知，就连为什么打工，他们都有充足的理由。 11.2 常量脚注比如引用图片的地址非常长，如果直接放到代码里面会影响可读性。我们可以把图片地址放到脚注里面，再在需要的地方引用。常量脚注的声明方式和引用脚注相似：[名称]: 内容 123[百度](baidu)[baidu]: https:\\\\baidu.com 百度 官方文档","tags":["工具","教程"],"categories":["教程"]},{"title":"Happy New Year -- 2023 !","path":"/2023/01/01/Happy-new-year-2023/","content":"","tags":["生活","杂记"],"categories":["杂记"]},{"title":"教师管理系统C语言(一)-系统介绍","path":"/2022/12/30/教师管理系统C语言(一)-系统介绍/","content":"一、目的和要求教师工资管理是较难处理的信息管理，使用传统方法，浪费时间，并不高效，并且数据容易丢失。为方便处理教师的信息，提高信息管理效率，此次项目设计为教师工资管理系统。 一个较为完善的教师工资管理系统，需要包含一个教师的完整信息：教师号、姓名、性别、单位名称、家庭住址、联系电话、基本工资、津贴、生活补贴、应发工资、电话费、水电费、房租、所得税、卫生费、公积金，需要对数据进行录入、排序，同时可以对其进行修改、删除、查询功能。本系统面对的对象是教师工资信息管理者，通过执行不同的功能选择，管理者能对教师工资信息进行相应的整理，从而提升信息管理效率。 我希望，通过这次程序设计可以增强我们对所学知识的更进一步认识，去熟悉掌握与灵活运用c语言，我将以所学的函数、数组、指针、链表、文件等知识来实现教师工资管理系统。 二、总体设计1. 基本思路利用链表，数组来对教师信息进行存储；通过函数，指针来对教师信息进行操作，实现相应的功能。 2. 设计思想：A.多个函数来实现整个系统的多个功能。例如，MainMenu函数将整个功能菜单打印出来，显示在界面上，让系统使用者清楚知道有那些功能选择。ShowAllTeacher函数可以遍历系统内存有的教师工资信息，而当想要浏览个别教师信息的时候，调用SearchTeacherById函数与SearchTeacherByName函数，可以分别通过教师号和名字查找到教师。以此类推，调用不同的函数，可以实现数据的录入，修改，删除，保存功能。 B.系统用一个结构体，记录每个教师所有工资信息，将存有数据的文件读取到链表当中，用链表的结点，来实现排序，删除等功能。 C.整个系统中最为重要的是指针。通过指针，可以指向任何变量（只要这个变量是在定义过的结构体内的变量），比数组更简洁迅速地找到目的变量，在实现精准查找，删除和修改等功能中起到了巨大的作用。 D.文件功能，实现将庞大的数据储存，打破数据过大的限制。存入特定的文件后，可以在下一次运行程序中打开文件，对文件的数据进行其他的操作。 3. 系统流程图图1.系统流程 三、数据及数据结构设计描述 struct Teacher为教师信息结构体，储存所有教师信息，通过其创造单向链表，其他功能对其操作从而实现教师的增删减改。 12345678910111213141516171819202122232425262728293031323334353637struct Teacher&#123;​\tint id;​\tchar name[10];​\tchar gender[5];​\tchar work_adress[20];​\tchar home_adress[20];​\tchar tel[11];​\tdouble salary; //基本工资 ​\tdouble allowance; //津贴 ​\tdouble living_all; //生活补贴​\tdouble tel_bill; //电话费 ​\tdouble water_electric_bill; //水电费 ​\tdouble room_charge; //房租​\tdouble income_tax; //所得税 ​\tdouble sanitation_fee; //卫生稅 ​\tdouble reserve_fund; //公积金​\tstruct Teacher* next;&#125;; 四、详细设计1.函数清单及说明1234567891011121314151617181920212223int MainMenu (); //开始主菜单 struct Teacher *ExtractTeacherOfFile(); //初始化链表（从文件提取数据）void ModifyTeacherInformation (struct Teacher *pHead); //信息修改 void AddTeacherInformation (struct Teacher *pHead); //信息录入 int IdIsExist (struct Teacher *pHead, int id); //判断教师号是否重复 void ShowTeacherInformation (struct Teacher *p); //展示教师信息 void DeleteTeacherInformation (struct Teacher *pHead); //信息删除 void SearchMenu (struct Teacher *pHead); //信息查找主菜单 void SearchTeacherById (struct Teacher *pHead); //教师号查找 void SearchTeacherByName (struct Teacher *pHead); //姓名查找 void ShowAllTeachers (struct Teacher *pHead); //查看所有教师信息 void ReserveTeacherInformation (struct Teacher *pHead); //保存信息，退出系统 2. 函数调用关系说明A. 主菜单–int MainMenu() 123456789101112struct Teacher *ExtractTeacherOfFile() //从文件提取教师数据void AddTeacherInformation(struct Teacher *pHead)void DeleteTeacherInformation(struct Teacher *pHead)void ModifyTeacherInformation(struct Teacher *pHead)void SearchMenu(struct Teacher *pHead)void ReserveTeacherInformation(struct Teacher *pHead) B. 录入教师信息–void AddTeacherInformation(struct Teacher *pHead) 1int IdIsExist(struct Teacher* pHead, int id) //判断教师号是否存在 C. 删除教师信息–void DeleteTeacherInformation(struct Teacher *pHead) 1void ShowTeacherInformation(ptem)//展示当前教师信息 D. 修改教师信息–void ModifyTeacherInformation(struct Teacher *pHead) 1void ShowTeacherInformation(ptem) E. 查找教师信息–void SearchMenu(struct Teacher *pHead) 1234567void ShowTeacherInformation(struct Teacher *ptem) void SearchTeacherById(struct Teacher *pHead) //教师号查询void SearchTeacherByName(struct Teacher *pHead) //名字查询void ShowAllTeachers(struct Teacher *pHead) //查看所有教师信息 F. 退出–void ReserveTeacherInformation(struct Teacher *pHead) 五、系统测试分析1. 主菜单程序运行后，成功进入主菜单，输入正确的功能选项可进入相应的功能模块，输入错误则刷新页面重新选择。 图2.主菜单 2. 录入教师信息选择功能“1”，进入教师信息的录入。录入信息完成后，根据提升可选择是否再次录入，选择否则退出教师录入功能。 图3.教师信息录入 3. 修改教师信息选择功能“2”进入教师信息修改功能，输入教师号，显示当前教师信息， 可选择相应修改项， 图4.选择修改项 确定不再需要修改或修改过一次选择“0”返回则显示修改后信息。 图5.修改后信息 未找到该教师则显示“该教师号不存在”，按任意键返回主菜单。 图6.未找到修改教师信息 4. 删除教师信息选择功能“3”进行教师信息删除，输入删除教师号，查找到则提示是否删除，确认删除，展示“删除成功”界面，按任意键返回主菜单。 图7.删除教师信息 若不存在该教师，则提示“该教师号不存在”，按任意键可返回主菜单。 5. 查询教师信息选择功能“4”进入教师信息查询，可选择相对应的查询方式来查询。 A. 以教师号查询 图8.教师号查询 B. 以姓名查询（图9） 图9.姓名查询 图10.查看所有教师信息 C. 查看所有教师信息（图10） D. 选择“0”退出 6. 保存教师信息，退出系统选择功能“0”实现教师信息保存与退出系统，保存成功则显示“保存成功”提示，按任意键退出系统。 图11. 保存教师信息 7. 教师数据提取每次系统运行会自动提取储存在文件中的数据，以防对文件操作导致教师数据丢失。关闭系统，再次打开，以功能“4”是否查找到教师信息为依据，判断是否成功提取。提取成功如图12。 图12.提取数据验证展示 六、其他拓展：系统面对对象可以分为两类：系统管理者与教师。系统管理者可以新增教师，或查看修改所有教师的任何信息，而教师只可以查看与更改自己的信息。同时，为保障所有信息的安全性，每位管理员或教师都有自己的用户名和密码。另外，可以增加教师的各项排名情况，使系统的功能更加多样化。 具体源码设计以及分析请等待更新。","tags":["C语言"],"categories":["实验设计"]},{"title":"数字钟的设计","path":"/2022/12/30/数字钟的设计/","content":"一、项目概况1. 设计目的数字钟的出现，给人类提供了巨大的便利，人类可以知道自己某个时刻具体干什么事。例如，秒表可以用来记录某一件事的所用的时间，时钟则可以记录一天的过程。本次项目设计目的，就是通过自己所学到的知识去设计一个简单数字钟，了解数字钟实现的原理，以及加强自己对所学知识的运用。 2. 项目构思要实现数字钟，需要有计数模块，它是是最核心的一部分；需要有对时钟信号进行分频的分频模块；需要有对输出结果的动态扫描、显示模块；以及还有设计拓展的各种小功能模块。基于这些模块功能设计，对其进行输入、输出互联，从而去实现一个具有功能性的数字钟。 二、方案设计1. 系统简介本次实现的数字钟系统中含有各个小模块，具体如下： a. 计数模块：数字钟计数的基础，通过计数来实现数字的变化，从而实现对时间变化的同步。 b. 分频模块：时钟信号的频率过快，我们需要对其实现分频，才可实现现实中1秒时间的变化。 c. 显示模块：对输出结果进行展示，通过输出绑定数码管，实现数字的显示。 d. 动态扫描模块：辅助显示模块，选择相应的数码管进行显示模块的输出显示。 e. 其他功能：基于以上模块，通过其输入输出的连接实现对数字钟的计数，暂停，清零功能。 2. 系统框图图1.系统框图 3. 各模块具体设计a. 计数模块： ①　秒，分（60进制）：利用两个74160分别实现个位计数与十位计数，用个位模块的74160进位端口RCO来实现十位的计数。当十位为0101和个位为1001时，重置计数。 图2.秒、分钟计数模块 ②　时（24进制）：利用两个74160分别实现个位计数与十位计数，用个位模块的74160进位端口RCO来实现十位的计数。当十位为0010和个位为0011时，重置计数。 图3.时钟计数模块 b. 分频模块： ①　利用plm实现对计数模块时钟信号的分频（clkk），设置26位比特位，模值为5010241024，从而得到1hz分频。 ②　利用plm实现对动态扫描计数部分的分频（lclk），通过不断测试，设置20位比特位，模值为25600显示结果正常。 图4.分频模块 c. 显示模块： 图5.显示模块 ①　数据选择器：具体设计如下图，通过动态扫描的数码管位选信号Q的值来选择对应数码管数据（传入的时、分、秒数据）的选择输出。 图6.数据选择器 ②　7447元件：翻译经数据选择器选择的数据信号，翻译成对应的数码管显示。 d. 动态扫描模块： 图7.动态扫描模块 前面的74160为模8计数器，重复的进行8个数码管的选择信号输出，74138通过选择信号控制相应数码管的输出，配合显示模块的时钟数据来进行输出。 e. 秒表，计时器的功能设计： ①　清零（clrn信号）： 通过74160异步置零端口CLRN实现，每个计数器连接上clrn控制信号，首先每个信号先加非门，保证没有任何操作时可以正常工作，但操作输入信号1时同时实现异步清零（连接方式如下图）。 ②　暂停（c信号）： 时钟信号与暂停控制信号组成与门，暂停控制信号后加非门，保证没有任何操作时可以正常工作，而当输入信号1时，通过与门实现对时钟信号的阻断，从而实现暂停（连接方式如下图）。 ③　校时（s信号）： 在时分秒三个计数模块加入控制信号。控制信号与每个计数器的进位信号组成或门，从而当输入脉冲控制信号时，在没有进位的情况下，每个模块能实现加法计数。（连接方式如下图） 图8.清零-暂停-校时 f. 准点报时功能： 通过判断秒钟与分钟的值，当它们都为00：00或00：01时，通过Q输出来控制输出实现报时效果。 图9.准点报时 4. 设计总图（电路连接总图）：图10.总线路设计 三、仿真与调试计数 仿真 a. 秒，分计数模块仿真： 图11 图12 如图所示，计数，进位正常，设计正确。 b. 小时模块仿真： 图13 如图所示，计数，进位正常，设计正确。 四、结果展示 （具体展示如视频附件） 图14 如图所示，数码管的选择功能正常，显示正常；准点报时功能正常（如图液晶模块边的单独数码管所示）；各功能（123为秒、分、时校时加法计数控制开关，456分别为秒、分、时暂停控制开关，8为清零开关）正常。 图15","tags":["数电","数字钟"],"categories":["实验设计"]},{"title":"博客搭建(一)-服务器的介绍与购买配置","path":"/2022/12/29/博客搭建(一)/","content":"非本专业者教程–不管是哪个行业，都可以拥有一个属于自己的博客，我们可以在自己的空间内自由发挥。如果你想搭建一个与我一样的博客或者网页，那你可以看看这个小系列文章。我将通过简单的步骤讲解让你简单了解服务器的概念以及如何去搭建、去简单使用服务器。本系列会持续补充完善… 前言：购买拥有服务器，虽然有很多优势与好处，但是对于非本专业者来说，还是略显繁琐与消耗金钱成本。所以，我在这里建议从下面这篇文章开始入手： 博客搭建(白嫖篇)https://wengui.work/2023/02/08/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA(%E7%99%BD%E5%AB%96%E7%AF%87)/ 通过这篇文章先学习了解博客的搭建与使用，如果后期有需求，再回到这里进行搭建。 什么是服务器或许你早已了解到这个名词——游戏服务器，你也可能听过“服务器崩了”这句话。那么什么是服务器？ 服务器，简单来说，你可以理解为一台时刻有网的“电脑”，我们可以通过网络随时访问这台“电脑”所开放的资源、数据。我们平常所用的电脑也可以当作服务器，我们只需要对其进行相关的配置，并使其不断网不断电，那么便可以成为一台服务器（当然，光是用电，成本就有些大）。游戏服务器便是存储游戏数据、返回数据请求的“电脑”。 实际上，服务器并不是电脑，但我们可以以电脑来理解（非计算机行业）。 购买服务器我们自用电脑可以满足充当服务器的作用，但成本有些大，所以，我们可以去云服务器商处购买。最推荐的服务器商：腾讯云，华为云，阿里云。 我们说说在这三个服务器商的好处： 每个用户都有一个月的体验机会 新用户有专属优惠（仅一次），一年的服务器只需100人民币左右。 后期服务好。 那么如何去购买服务器？ 这里我们以腾讯云为例： 我们浏览器搜索“腾讯云”，或者直接点击这里前往去注册登录，进去首页我们可以看到“免费试用”活动以及“新用户专享”活动。 免费试用页面 新用户专享页面 选择哪款？无论是试用还是购买，我们都选择轻量应用服务器，2核2G或2核4G的配置便已足够我们的需求，当然，试用我们选择最高配置（配置如上图）。 购买时，会出现地域和系统的选择，地域我们根据个人来选即可，系统我们便选择Ubuntu20.4。接着我们返回主页，点击控制台，点击轻量应用服务器。随后是如下页面： 查看服务器详情 我们点击查看详情，接下来去重置我们的密码，同时我们需注意一下我们的公网IP，我们后续可以用IP地址访问我们的网站。 至此，我们便成功购买服务器并重置了密码。 查看详情页面介绍这里介绍几个需要用到的几个页面： 域名域名管理。本博客wengui.work便是域名，通过域名与IP地址绑定，我们的网站不需要通过纯数字的地址访问，使得我们的网站便于其他人记住。如不需要域名，可不设置。 防火墙设置我们开放的端口。我们的程序会运行到某些端口，外界可以通过开放的端口访问我们的资源。如8.8.8.8:8080，这是指8.8.8.8这台电脑的8080端口。我们常见的www.baidu.com也是通过端口访问的，未写端口号默认在访问80端口。我们可以点击“添加规则”进行端口设置： 添加规则 快照服务器历史状态。当你在操作服务器主机（电脑）时，安装了某些东西导致出现了某些错误或者某些情况时，你可以通过快照返回到之前的历史状态。如：当电脑安装了QQ后，我们先保存了快照，我们此时去安装微信。这时候可能说安装微信过程中我们出现了问题。这时候我们可以通过快照返回到我们保存的刚刚安装完QQ后的状态。添加快照如：","tags":["博客"],"categories":["博客搭建"]},{"title":"bug日志","path":"/2022/12/28/bug日志/","content":"BUG日志2023-111-8 15:38 : 智库-项目内文章图片无法显示 2022-121212-30 15:38 : 头像未显示 [已解决： 12-30 15:45]12-30 15:21 : 手机端(部分浏览器)无法加载图片 [猜测部分浏览器无法兼容]","tags":["bug"],"categories":["日志记录"]},{"title":"JavaSE 概览","path":"/wiki/JavaSE/index.html","content":"JavaSE 知识库概览Java学习基础。目录概览： 多线程"},{"title":"多线程","path":"/wiki/JavaSE/多线程.html","content":"多线程介绍线程（thread）是一个程序内部的一条执行路径。如我们启动main方法其实就是启动一条单独的执行路径。 多线程是指从软硬件实现多条执行流程的技术。 如：当我们在百度网盘下载文件时，我们也可以上传文件，这是两个线程。 快速体验定义一个线程类MyThread，并在main方法中启动线程： 1234567891011121314151617181920212223242526package thread;public class threadDemo1 &#123; public static void main(String[] args) &#123; //创建线程对象 MyThread myThread = new MyThread(); //调用 start 方法启动线程 myThread.start(); //主线程输出 for (int i = 0; i&lt;5; i++)&#123; System.out.println(&quot;主线程输出: &quot; + i); &#125; &#125;&#125;//创建线程类继承 Thread类class MyThread extends Thread&#123; @Override public void run() &#123; //重写 run 方法 for (int i = 0; i&lt;5; i++)&#123; System.out.println(&quot;子线程输出: &quot; + i); &#125; &#125;&#125; 我们运行，控制台输出如下： 12345678910主线程输出: 0子线程输出: 0主线程输出: 1子线程输出: 1子线程输出: 2主线程输出: 2子线程输出: 3主线程输出: 3子线程输出: 4主线程输出: 4 我们注意到，主线程与子线程不规则的交替输出(线程间的竞争性，抢占CPU资源)，当我们再次重新运行时，输出的结果会不一样。 多线程的创建Java 提供了三种创建线程的方法： 1. 继承 Thread 类本身实现方法： 定义一个线程类MyThread继承线程类Thread 类 重写 run() 方法 创建线程对象 调用 start() 方法启动 1234567891011121314151617//MyThread.javapublic class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;hello , Thread&quot;); &#125;&#125;//threadDemo1.javapublic class threadDemo1 &#123; public static void main(String[] args) &#123; //创建线程对象 MyThread myThread = new MyThread(); //调用 start 方法启动线程 myThread.start(); &#125;&#125; 此方法优缺点： 优点: 编码简单 缺点: 线程类已继承Thread类，无法继承其他类，不利于拓展 2. 实现 Runnable 接口实现方法： 定义一个线程任务类 MyRunnable 实现 Runnable 接口，重写 run() 方法 创建 MyRunnable 对象 把 MyRunnable 交给 Thread 处理 调用线程对象的 start() 方法启动线程 123456789101112131415161718192021//MyRunnable.javapublic class MyRunnable implements Runnable&#123; //重写 run 方法 @Override public void run() &#123; System.out.println(&quot;hello Runnable&quot;); &#125;&#125;//threadDemo2.javapublic class threadDemo2 &#123; public static void main(String[] args) &#123; //创建任务对象 MyRunnable target = new MyRunnable(); //把 MyRunnable 交给 Thread 处理 Thread thread = new Thread(target); //启动线程 thread.start(); &#125;&#125; 此方法优缺点： 优点: Runnable是接口，线程任务类可以继承其他类和实现多个接口，拓展性强 缺点: 编程多一层对象包装，若线程有返回结果不可以直接返回 3. 通过 Callable 和 Future 创建线程实现方法： 定义类实现Clalable接口，重写 call() 方法 用FutureTask把Clalable对象封装成线程任务对象 把线程任务交给Thread处理 调用Thread的 start() 方法启动线程 线程执行完毕后，通过FutureTask 的 get() 方法获取任务执行的结果 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class threadDemo3&#123; public static void main(String[] args) &#123; //创建 Callable 任务对象 Callable&lt;String&gt; callable = new MyCallable(); //把 Callable 任务对象交给 FutureTask 对象 //FutureTask 对象: 实现了 Runnable 接口, 可以交给 Thread FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(callable); //交给 Thread 处理 Thread thread = new Thread(futureTask); //启动 thread.start(); //FutureTask 的 get() 方法获取返回结果 try &#123; System.out.println(futureTask.get()); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125;class MyCallable implements Callable&lt;String &gt; &#123; //重写 call 方法 @Override public String call() throws Exception &#123; return &quot;Hello! Callable and FutureTask&quot;; &#125;&#125; 此方法优缺点： 优点: 线程任务类可以继承其他类和实现多个接口，拓展性强，可获取线程返回结果 缺点: 编码复杂 线程常用方法最常用构造器与方法(加粗)如下： 构造器构造器描述Thread()分配新的 Thread对象。Thread(Runnable target)将Runnable对象交给Thread,分配新的 Thread对象。Thread(Runnable target, String name)将Runnable对象交给Thread，并指定线程名称Thread(String name)指定线程名称，分配新的 Thread对象。Thread(ThreadGroup group, Runnable target)分配新的 Thread对象。Thread(ThreadGroup group, Runnable target, String name)分配新的 Thread对象，使其具有 target作为其运行对象，具有指定的 name作为其名称，并且属于 group引用的线程组。Thread(ThreadGroup group, Runnable target, String name, long stackSize)分配新的 Thread对象，使其具有 target作为其运行对象，具有指定的 name作为其名称，并且属于 group引用的线程组，并具有指定的 堆栈大小 。Thread(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals)分配新的Thread对象，使其具有target作为其运行对象，具有指定的name作为其名称，属于group引用的线程组，具有指定的stackSize ，并且如果inheritThreadLocals是true ，则继承inheritable thread-local变量的初始值。Thread(ThreadGroup group, String name)分配新的 Thread对象方法变量和类型方法描述static intactiveCount()返回当前线程thread group及其子组中活动线程数的估计值。voidcheckAccess()确定当前运行的线程是否具有修改此线程的权限。protected Objectclone()抛出CloneNotSupportedException，因为无法有意义地克隆线程。intcountStackFrames()不推荐使用，要删除：此API元素将在以后的版本中删除。 此调用的定义取决于suspend() ，已弃用。static ThreadcurrentThread()返回对当前正在执行的线程对象的引用。static voiddumpStack()将当前线程的堆栈跟踪打印到标准错误流。static intenumerate(Thread[] tarray)将当前线程的线程组及其子组中的每个活动线程复制到指定的数组中。static Map&lt;Thread,StackTraceElement[]&gt;getAllStackTraces()返回所有活动线程的堆栈跟踪映射。ClassLoadergetContextClassLoader()返回此线程的上下文 ClassLoader 。static Thread.UncaughtExceptionHandlergetDefaultUncaughtExceptionHandler()返回由于未捕获的异常而导致线程突然终止时调用的默认处理程序。longgetId()返回此Thread的标识符。StringgetName()返回此线程的名称。intgetPriority()返回此线程的优先级。StackTraceElement[]getStackTrace()返回表示此线程的堆栈转储的堆栈跟踪元素数组。Thread.StategetState()返回此线程的状态。ThreadGroupgetThreadGroup()返回此线程所属的线程组。Thread.UncaughtExceptionHandlergetUncaughtExceptionHandler()返回此线程由于未捕获的异常而突然终止时调用的处理程序。static booleanholdsLock(Object obj)当且仅当当前线程在指定对象上保存监视器锁时，返回 true 。voidinterrupt()中断此线程。static booleaninterrupted()测试当前线程是否已被中断。booleanisAlive()测试此线程是否存活。booleanisDaemon()测试此线程是否为守护程序线程。booleanisInterrupted()测试此线程是否已被中断。voidjoin()等待这个线程死亡。voidjoin(long millis)此线程最多等待 millis毫秒。voidjoin(long millis, int nanos)此线程最多等待 millis毫秒加上 nanos纳秒。static voidonSpinWait()表示调用者暂时无法进展，直到其他活动发生一个或多个操作为止。voidresume()已过时。 此方法仅适用于suspend()，由于它易于死锁，因此已被弃用。voidrun()如果此线程是使用单独的Runnable运行对象构造的，则调用该Runnable对象的run方法; 否则，此方法不执行任何操作并返回。voidsetContextClassLoader(ClassLoader cl)为此Thread设置上下文ClassLoader。voidsetDaemon(boolean on)将此线程标记为 daemon线程或用户线程。static voidsetDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)设置当线程由于未捕获的异常而突然终止时调用的默认处理程序，并且没有为该线程定义其他处理程序。voidsetName(String name)将此线程的名称更改为等于参数 name 。voidsetPriority(int newPriority)更改此线程的优先级。voidsetUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)设置当此线程由于未捕获的异常而突然终止时调用的处理程序。static voidsleep(long millis)导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数，具体取决于系统计时器和调度程序的精度和准确性。static voidsleep(long millis, int nanos)导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数加上指定的纳秒数，具体取决于系统定时器和调度程序的精度和准确性。voidstart()导致此线程开始执行; Java虚拟机调用此线程的run方法。voidstop()已过时。 这种方法本质上是不安全的。voidsuspend()已过时。 此方法已被弃用，因为它本身就容易出现死锁。StringtoString()返回此线程的字符串表示形式，包括线程的名称，优先级和线程组。static voidyield()向调度程序提示当前线程是否愿意产生其当前使用的处理器。 线程安全线程安全问题：多个线程同时操作同一个共享资源时可能会出现业务安全问题。 如：小红和小明一对夫妻同时银行去取钱，两人同时登录并进行取款5万（卡里余额五万），由于同时进行取款，这时候系统查询余额足够，两人都有权限进行五万元的取款，由此导致安全问题。 我们来模拟一下场景： 我们先创建一个银行卡对象： 1234567891011121314151617181920212223public class Account &#123; private String carId; private Double money; Account(String carId, Double money)&#123; this.carId = carId; this.money = money; &#125; public void drawMoney(Double drawmoney)&#123; //获取当前是谁来取钱，便于确认 String threadName = Thread.currentThread().getName(); //判断余额 if(money &gt;= drawmoney)&#123; System.out.println(threadName + &quot;来取钱了&quot;); money -= drawmoney; System.out.println(threadName + &quot;取出&quot; + drawmoney + &quot;元后, 余额为&quot; + money); &#125;else &#123; System.out.println(&quot;余额不足&quot;); &#125; &#125;&#125; 实现一下线程逻辑： 12345678910111213141516public class MyThread extends Thread&#123; private Account account; private Double money; MyThread(Account account, String name, Double money) &#123; //调用父类构造器给当前进程取名 super(name); this.account = account; this.money = money; &#125; @Override public void run() &#123; account.drawMoney(money); &#125;&#125; 然后我们启动线程，模拟场景： 123456789101112public class threadDemo4 &#123; public static void main(String[] args) &#123; Account account = new Account(&quot;12138&quot;,50000.0); //创建线程 MyThread myThread1 = new MyThread(account, &quot;小红&quot;, 50000.0); MyThread myThread2 = new MyThread(account, &quot;小明&quot;, 50000.0); //启动线程 myThread1.start(); myThread2.start(); &#125;&#125; 最后运行查看输出： 1234小红来取钱了小明来取钱了小红取出50000.0元后, 余额为0.0小明取出50000.0元后, 余额为-50000.0 可见，引发了安全问题。当然我们实际生活中不会出现这种问题，我们有解决的方案。 线程同步解决线程安全问题。 核心思想–加锁，把共享资源进行上锁，每次只能一个线程进入，访问完毕后才解锁，然后其他线程访问进来。 1. 同步代码块把出现问题的核心代码上锁： 123synchronized(同步锁对象)&#123; 操作共享资源的代码；&#125; 对于以上场景，我们进行加锁，只需在操作共享资源的代码块进行加锁： 123456789101112131415public void drawMoney(Double drawmoney)&#123; //获取当前是谁来取钱，便于确认 String threadName = Thread.currentThread().getName(); System.out.println(threadName + &quot;来取钱了&quot;); //加锁， this 为当前对象 synchronized (this)&#123; //判断余额 if(money &gt;= drawmoney)&#123; money -= drawmoney; System.out.println(threadName + &quot;取出&quot; + drawmoney + &quot;元后, 余额为&quot; + money); &#125;else &#123; System.out.println(threadName + &quot;来取钱了&quot; + &quot;余额不足&quot;); &#125; &#125; 我们再次运行查看结果： 1234小明来取钱了小红来取钱了小明取出50000.0元后, 余额为0.0小红来取钱了余额不足 我们发现运行正常了。 我们来说说原理：当我们加锁时，当两个线程访问共享资源时，两者会竞争锁，同时存在时间维度的先后，synchronized 中有竞争算法来实现访问的先后，先进入的线程可以访问共享资源，而未竞争到的线程会等待上一个线程访问结束后才可以进行访问共享资源。 锁对象的规范： 理论上，任意唯一的对象都可以作为锁对象（存在问题）；但规范上建议使用共享资源 实例方法建议使用 this 作为锁对象 静态方法建议使用字节码（类名.class）对象作为锁对象 2. 同步方法把出现问题的核心方法上锁： 123修饰符 synchronized 返回值类型 方法名 (形参列表)&#123; 操作共享资源的代码&#125; 我们再次对drawMoney进行加锁： 123456789101112131415//同步方法public synchronized void drawMoney(Double drawmoney)&#123; //获取当前是谁来取钱，便于确认 String threadName = Thread.currentThread().getName(); System.out.println(threadName + &quot;来取钱了&quot;); //判断余额 if(money &gt;= drawmoney)&#123; money -= drawmoney; System.out.println(threadName + &quot;取出&quot; + drawmoney + &quot;元后, 余额为&quot; + money); &#125;else &#123; System.out.println(threadName + &quot;来取钱了&quot; + &quot;余额不足&quot;); &#125;&#125; 我们再次查看运行结果： 1234小明来取钱了小明取出50000.0元后, 余额为0.0小红来取钱了小红来取钱了余额不足 此方法特点： 同步方法也是有隐式锁对象，锁的范围是整个方法代码 如果是实例方法，默认使用 this 作为锁对象，但是代码要高度面对对象 如果是静态方法，默认使用 类名.class 作为锁对象 3. Lock锁为了更清晰的表达如何加锁和释放锁，JDK1.5 以后提供的锁对象 Lock 特点： Lock提供了更广泛的锁定操作 Lock是接口，不能直接实例化，需要使用它的实现类ReentrantLock来创建Lock锁对象 Luck方法:变量和类型方法描述voidlock()获得锁。voidlockInterruptibly()除非当前线程是 interrupted否则获取锁定。ConditionnewCondition()返回一个新Condition绑定到该实例Lock实例。booleantryLock()只有在调用时它是空闲的才能获取锁。booleantryLock(long time, TimeUnit unit)如果锁在给定的等待时间内是空闲的并且当前线程不是 interrupted ，则获取锁。voidunlock()释放锁定。ReentrantLock API：变量和类型方法描述intgetHoldCount()查询当前线程对此锁定的保持数。protected ThreadgetOwner()返回当前拥有此锁的线程，如果不拥有，则返回 null 。protected Collection&lt;Thread&gt;getQueuedThreads()返回包含可能正在等待获取此锁的线程的集合。intgetQueueLength()返回等待获取此锁的线程数的估计值。protected Collection&lt;Thread&gt;getWaitingThreads(Condition condition)返回一个集合，其中包含可能正在等待与此锁定关联的给定条件的那些线程。intgetWaitQueueLength(Condition condition)返回在与此锁定关联的给定条件上等待的线程数的估计值。booleanhasQueuedThread(Thread thread)查询给定线程是否正在等待获取此锁定。booleanhasQueuedThreads()查询是否有任何线程正在等待获取此锁。booleanhasWaiters(Condition condition)查询是否有任何线程正在等待与此锁定关联的给定条件。booleanisFair()如果此锁定的公平性设置为true，则返回 true 。booleanisHeldByCurrentThread()查询当前线程是否持有此锁定。booleanisLocked()查询此锁是否由任何线程持有。voidlock()获得锁。voidlockInterruptibly()除非当前线程是 interrupted，否则获取锁定。ConditionnewCondition()返回Condition实例以与此Lock实例一起使用。StringtoString()返回标识此锁的字符串及其锁定状态。booleantryLock()只有在调用时没有被另一个线程持有时才获取锁。booleantryLock(long timeout, TimeUnit unit)如果在给定的等待时间内没有被另一个线程持有并且当前线程不是 interrupted，则获取锁。voidunlock()尝试释放此锁定。 我们继续对Account类继续更改： 123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Account &#123; private String carId; private Double money; private final Lock lock = new ReentrantLock(); Account(String carId, Double money)&#123; this.carId = carId; this.money = money; &#125; //同步方法 public void drawMoney(Double drawmoney)&#123; //获取当前是谁来取钱，便于确认 String threadName = Thread.currentThread().getName(); System.out.println(threadName + &quot;来取钱了&quot;); //上锁 lock.lock(); try &#123; //判断余额 if(money &gt;= drawmoney)&#123; money -= drawmoney; System.out.println(threadName + &quot;取出&quot; + drawmoney + &quot;元后, 余额为&quot; + money); &#125;else &#123; System.out.println(threadName + &quot;来取钱了&quot; + &quot;余额不足&quot;); &#125; &#125; finally &#123; //解锁 lock.unlock(); &#125; &#125;&#125; 以上便可完成线程同步。"},{"title":"线程池","path":"/wiki/JavaSE/线程池.html","content":"线程池介绍线程池是一个可以复用线程的技术。 如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要再次创建新线程，而线程的创建对于系统的开销是很大的，会严重影响系统性能。 线程池便是为处理这一状况。 工作流程提交一个任务到线程池中，线程池的工作流程如下： 判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。 线程池判断任务队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。 判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 具体的分析请浏览下文中： 线程池的使用以及分析 线程池的创建我们先来了解一下： ExecutorService 和ThreadPoolExecutor。 1. ExecutorServiceJDK5提供的代表线程池的接口，我们只需了解其方法。 变量和类型 方法 描述 void execute(Runnable command) Executor接口中的方法,在将来的某个时间执行给定的命令。 boolean awaitTermination(long timeout, TimeUnit unit) 阻止所有任务在关闭请求之后完成执行，或发生超时，或者当前线程被中断，以先发生者为准。 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) 执行给定的任务，返回完成所有状态和结果的Futures列表。 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) 执行给定的任务，返回一个Futures列表，在完成或超时到期时保持其状态和结果，以先发生者为准。 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) 执行给定的任务，返回已成功完成的任务的结果（即，不抛出异常），如果有的话。 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) 执行给定的任务，返回已成功完成的任务的结果（即，不抛出异常），如果在给定的超时之前已经执行了任何操作。 boolean isShutdown() 如果此执行程序已关闭，则返回 true 。 boolean isTerminated() 如果关闭后所有任务都已完成，则返回 true 。 void shutdown() 启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务。 List&lt;Runnable&gt; shutdownNow() 尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行的任务列表。 Future&lt;?&gt; submit(Runnable task) 提交Runnable任务以执行并返回表示该任务的Future。 &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) 提交Runnable任务以执行并返回表示该任务的Future。 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) 提交值返回任务以执行并返回表示任务的挂起结果的Future。 2. ThreadPoolExecutorExecutorService的实现类ThreadPoolExecutor，可以创建一个线程池对象 12345678//构造器public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 构造器构造器描述ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)使用给定的初始参数创建新的 ThreadPoolExecutor ，默认线程工厂和默认拒绝执行处理程序。ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)创建一个新的 ThreadPoolExecutor给定的初始参数和 default thread factory 。ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)创建一个新的ThreadPoolExecutor给定的初始参数和default rejected execution handler。ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)使用给定的初始参数创建新的 ThreadPoolExecutor 。方法变量和类型方法描述protected voidafterExecute(Runnable r, Throwable t)完成给定Runnable的执行后调用的方法。voidallowCoreThreadTimeOut(boolean value)设置管理核心线程是否可以超时并在保持活动时间内没有任务到达时终止的策略，在新任务到达时根据需要进行替换。booleanallowsCoreThreadTimeOut()如果此池允许核心线程超时并在keepAlive时间内没有任务到达时终止，则返回true，在新任务到达时根据需要进行替换。protected voidbeforeExecute(Thread t, Runnable r)在给定线程中执行给定Runnable之前调用的方法。voidexecute(Runnable command)将来某个时候执行给定的任务。protected voidfinalize()已过时。intgetActiveCount()返回正在执行任务的大致线程数。longgetCompletedTaskCount()返回已完成执行的大致任务总数。intgetCorePoolSize()返回核心线程数。longgetKeepAliveTime(TimeUnit unit)返回线程保持活动时间，它是线程在终止之前保持空闲的时间量。intgetLargestPoolSize()返回同时存在于池中的最大线程数。intgetMaximumPoolSize()返回允许的最大线程数。intgetPoolSize()返回池中当前的线程数。BlockingQueue&lt;Runnable&gt;getQueue()返回此执行程序使用的任务队列。RejectedExecutionHandlergetRejectedExecutionHandler()返回不可执行任务的当前处理程序。longgetTaskCount()返回已安排执行的大致任务总数。ThreadFactorygetThreadFactory()返回用于创建新线程的线程工厂。booleanisTerminating()如果此执行程序在 shutdown()或 shutdownNow()之后终止但尚未完全终止，则返回true。intprestartAllCoreThreads()启动所有核心线程，导致它们无所事事地等待工作。booleanprestartCoreThread()启动一个核心线程，导致它无所事事地等待工作。voidpurge()尝试从工作队列中删除已取消的所有Future任务。booleanremove(Runnable task)如果执行程序的内部队列存在，则从执行程序的内部队列中删除此任务，从而导致它在尚未启动时不会运行。voidsetCorePoolSize(int corePoolSize)设置核心线程数。voidsetKeepAliveTime(long time, TimeUnit unit)设置线程保持活动时间，即线程在终止之前可以保持空闲的时间量。voidsetMaximumPoolSize(int maximumPoolSize)设置允许的最大线程数。voidsetRejectedExecutionHandler(RejectedExecutionHandler handler)为不可执行的任务设置新的处理程序。voidsetThreadFactory(ThreadFactory threadFactory)设置用于创建新线程的线程工厂。voidshutdown()启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务。List &lt; Runnable&gt;shutdownNow()尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行的任务列表。protected voidterminated()Executor终止时调用的方法。StringtoString()返回标识此池及其状态的字符串，包括运行状态和估计的工作和任务计数的指示。 参数介绍： corePoolSize：线程池核心线程数量，不能小于 0 。 maximumPoolSize: 线程池可支持的最大线程数量，最大数量 &gt;&#x3D; 核心线程数量。 keepAliverTime：当活跃线程数大于核心线程数时，临时线程的最大存活时间, 不能小于 0 。 unit：存活时间的单位，不能为 null 。 workQueue：存放任务的队列，不能为 null 。 handler：超出线程范围和队列容量的任务的处理程序，不能为 null 。 1.临时线程的创建时机：新任务提交时，发现核心线程在忙，任务队列已满且还可以创建临时线程，此时才会创建。 2.拒绝任务的时机：核心线程和临时线程都在忙，任务队列已满，此时开始拒绝任务。 线程池的使用以及分析首先我们先创建一个线程 , 实现其方法： 12345678public class MyRunnable implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot;输出了&quot; + i); &#125; &#125;&#125; 然后，我们再创建线程池，3个核心线程，最大线程5个（也就是临时线程只能创建2个），任务队列为5。 我们首先启动3个线程任务： 12345678910111213141516import java.util.concurrent.*;public class threadPoolDemo1 &#123; public static void main(String[] args) &#123; //创建 线程池 对象 ExecutorService pool = new ThreadPoolExecutor(3,5,6, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(5), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); //创建 线程 对象 Runnable target = new MyRunnable(); //将 3个线程任务 放入线程池 pool.execute(target); pool.execute(target); pool.execute(target); &#125;&#125; 运行结果如下： 123456789pool-1-thread-3输出了0pool-1-thread-1输出了0pool-1-thread-2输出了0pool-1-thread-1输出了1pool-1-thread-3输出了1pool-1-thread-1输出了2pool-1-thread-2输出了1pool-1-thread-3输出了2pool-1-thread-2输出了2 我们看到，3个线程在工作并执行输出。 随后，我们测试5个线程任务，对其代码进行改进增加线程： 123456789101112131415161718import java.util.concurrent.*;public class threadPoolDemo1 &#123; public static void main(String[] args) &#123; //创建 线程池 对象 ExecutorService pool = new ThreadPoolExecutor(3,5,6, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(5), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); //创建 线程 对象 Runnable target = new MyRunnable(); //将 5个线程任务 放入线程池 pool.execute(target); pool.execute(target); pool.execute(target); pool.execute(target); pool.execute(target); &#125;&#125; 我们再次运行查看结果： 1234567891011121314pool-1-thread-3输出了0pool-1-thread-1输出了0pool-1-thread-3输出了1pool-1-thread-3输出了2 --1pool-1-thread-2输出了1pool-1-thread-1输出了1pool-1-thread-3输出了0pool-1-thread-3输出了1pool-1-thread-2输出了2 --2pool-1-thread-3输出了2 --3pool-1-thread-1输出了2 --4pool-1-thread-2输出了0pool-1-thread-2输出了1pool-1-thread-2输出了2 --5 我们发现，还是3个线程在工作，这3个线程便是我们线程池设置的3个核心线程。但是5个线程任务都已完成，说明我们的任务执行时依靠我们的核心线程来完成的。我们的3个核心线程优先处理3个线程任务，剩下两个任务便放在任务队列中等待核心线程完成上一个任务，随后执行。 上述例子均没有临时线程的出现，我们测试11个线程任务，因线程较多，我们同时对线程类MyRunnable进行改进： 123456public class MyRunnable implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot;在执行 ！&quot;); &#125;&#125; 123456789101112131415161718192021222324import java.util.concurrent.*;public class threadPoolDemo1 &#123; public static void main(String[] args) &#123; //创建 线程池 对象 ExecutorService pool = new ThreadPoolExecutor(3,5,6, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(5), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); //创建 线程 对象 Runnable target = new MyRunnable(); //将 11个线程任务 放入线程池 pool.execute(target); pool.execute(target); pool.execute(target); pool.execute(target); pool.execute(target);\t//5 pool.execute(target); pool.execute(target); pool.execute(target); pool.execute(target)； pool.execute(target);\t//10 pool.execute(target); &#125;&#125; 随后，我们查看结果： 12345678910pool-1-thread-3在执行 ！pool-1-thread-4在执行 ！pool-1-thread-1在执行 ！pool-1-thread-5在执行 ！pool-1-thread-1在执行 ！\t--5pool-1-thread-2在执行 ！pool-1-thread-1在执行 ！pool-1-thread-5在执行 ！pool-1-thread-3在执行 ！pool-1-thread-4在执行 ！\t--10 我们发现，thread-4和thread-5出现了。我们执行11个线程任务，核心线程执行前面的3个线程任务，随后提交的5个存进任务队列，而后面提交的3个线程任务，发现核心线程在工作，任务队列也满了，此时会创建临时线程来处理这个线程任务。线程池中最大线程数是5，所以有两个线程任务会优先被临时线程来处理，然后临时线程再执行任务队列的线程任务。最后一个线程任务由于5个线程都在工作，任务队列已满，而被饱和（拒绝）策略ThreadPoolExecutor.AbortPolicy()给拒绝，故只输出了10个结果。若第11个线程任务晚一些提交，则线程队列会有剩余空间，第11个线程任务将会被执行。 EXecutorsEXecutors 是线程池的工具类，通过调用方法返回不同的线程池对象。 常用的方法（加粗）如下: 变量和类型 方法 描述 static Callable&lt;Object&gt; callable(Runnable task) 返回一个Callable对象，该对象在调用时运行给定任务并返回null。 static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) 返回一个Callable对象，该对象在调用时运行给定任务并返回给定结果。 static Callable&lt;Object&gt; callable(PrivilegedAction&lt;?&gt; action) 返回一个Callable对象，该对象在调用时运行给定的特权操作并返回其结果。 static Callable&lt;Object&gt; callable(PrivilegedExceptionAction&lt;?&gt; action) 返回一个Callable对象，该对象在调用时运行给定的特权异常操作并返回其结果。 static ThreadFactory defaultThreadFactory() 返回用于创建新线程的默认线程工厂。 static ExecutorService newCachedThreadPool() 创建一个根据需要创建新线程的线程池，线程数量随着任务的增加而增加，如果线程执行完毕且空闲了一段时间则被回收。 static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) 创建一个根据需要创建新线程的线程池，但在它们可用时将重用以前构造的线程，并在需要时使用提供的ThreadFactory创建新线程。 static ExecutorService newFixedThreadPool(int nThreads) 创建固定线程数量线程池，如果线程因执行异常而结束，则创建一个新线程替代它。 static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) 创建一个线程池，该线程池重用在共享的无界队列中运行的固定数量的线程，使用提供的ThreadFactory在需要时创建新线程。 static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个线程池，可以调度命令在给定的延迟后运行，或者定期执行。 static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) 创建一个线程池，可以调度命令在给定的延迟后运行，或者定期执行任务。 static ExecutorService newSingleThreadExecutor() 创建一个Executor，只有一个线程再工作，在无界队列中运行。 static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) 创建一个Executor，它使用一个在无界队列中运行的工作线程，并在需要时使用提供的ThreadFactory创建一个新线程。 static ScheduledExecutorService newSingleThreadScheduledExecutor() 创建一个单线程执行程序，可以调度命令在给定的延迟后运行，或定期执行。 static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) 创建一个单线程执行程序，可以调度命令在给定的延迟后运行，或定期执行。 static ExecutorService newWorkStealingPool() 使用 available processors的数量作为其目标并行度级别创建工作窃取线程池。 static ExecutorService newWorkStealingPool(int parallelism) 创建一个线程池，该线程池维护足够的线程以支持给定的并行度级别，并可以使用多个队列来减少争用。 static &lt;T&gt; Callable&lt;T&gt; privilegedCallable(Callable&lt;T&gt; callable) 返回一个Callable对象，在调用时，将在当前访问控制上下文下执行给定的callable 。 static &lt;T&gt; Callable&lt;T&gt; privilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; callable) 返回一个Callable对象，当调用该对象时，将在当前访问控制上下文下执行给定的callable ，并将当前上下文类加载器作为上下文类加载器。 static ThreadFactory privilegedThreadFactory() 返回一个线程工厂，用于创建与当前线程具有相同权限的新线程。 static ExecutorService unconfigurableExecutorService(ExecutorService executor) 返回一个对象，该对象将所有已定义的ExecutorService方法委派给给定的执行程序，但不能使用强制转换可以访问的任何其他方法。 static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor) 返回一个对象，该对象将所有已定义的ScheduledExecutorService方法委托给给定的执行程序，但不能使用强制转换可以访问的任何其他方法。 皆是静态方法，可以直接调用。 底层是基于线程池的实现类 ThreadPoolExecutor创建线程池对象。 方法使用： 12//创建 固定线程数量 的线程池EXecutorService pool = Executors.newFixdThreadPool(3); 注意 1.大型并发系统环境中使用 Executor如果不注意可能出现系统风险，如 允许请求的任务队列长度是 Integer.MAX_VALUE，可能出现OOM错误（java.lang.OutOfMemeryError） 创建的线程数量最大上限是 Integer.MAX_VALUE，线程数可能随任务1：1增加，可能出现OOM错误（java.lang.OutOfMemeryError） 2.阿里巴巴开发手册案例："},{"title":"CSS","path":"/wiki/JavaWeb/CSS.html","content":"1. 概述W3C标准规定了网页是由以下组成： 结构：HTML 表现：CSS 行为：JavaScript CSS：Cascading Style Sheet（层叠样式表），一种标准的样式表语言，用于描述网页的表现形式（例如网页元素的位置、大小、颜色等）。 2. css 导入方式CSS 导入 HTML有三种方式： 内联样式：在标签内部使用style属性，属性值是css属性键值对 1&lt;div style=&quot;color: red&quot;&gt;Hello CSS~&lt;/div&gt; 只能作用于这一个标签上，复用性差。 内部样式：定义style标签，在标签内部定义css样式 12345&lt;style type=&quot;text/css&quot;&gt;\tdiv&#123; color: red; &#125;&lt;/style&gt; 这种方式可以做到在该页面中复用。 外部样式：定义link标签，引入外部的css文件 如有demo.css的css文件，内容如下: 123div&#123;\tcolor: red;&#125; 在html中引入 css 文件。 1&lt;link rel=&quot;stylesheet&quot; href=&quot;demo.css&quot;&gt; 可以在多个页面进行复用。其他的页面想使用同样的样式，只需要使用 link 标签引入该css文件。 3. css 选择器css 选择器就是选取需设置样式的元素（标签），比如如下css代码： 123div &#123;\tcolor:red;&#125; 上述代码中的 div 就是 css 中的选择器。简单演示下面三种选择器： 元素选择器 语法： 1元素名称&#123;color: red;&#125; 例： 1div &#123;color:red&#125; id选择器 语法： 1#id属性值&#123;color: red;&#125; 例： html代码如下： 1&lt;div id=&quot;name&quot;&gt;hello css2&lt;/div&gt; css代码如下： 1#name&#123;color: red;&#125; 类选择器 语法： 1.class属性值&#123;color: red;&#125; 例： html代码如下： 1&lt;div class=&quot;cl&quot;&gt;hello CSS&lt;/div&gt; css代码如下： 1.cl&#123;color: red;&#125; 更多选择器用法如下： 选择器 例子 例子描述 .class .intro 选择 class&#x3D;”intro” 的所有元素。 .class1.class2 .name1.name2 选择 class 属性中同时有 name1 和 name2 的所有元素。 .class1 .class2 .name1 .name2 选择作为类名 name1 元素后代的所有类名 name2 元素。 #id #firstname 选择 id&#x3D;”firstname” 的元素。 * * 选择所有元素。 element p 选择所有 &lt;p&gt; 元素。 element.class p.intro 选择 class&#x3D;”intro” 的所有 &lt;p&gt; 元素。 element,element div, p 选择所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素。 element element div p 选择 &lt;div&gt; 元素内的所有 &lt;p&gt; 元素。 element&gt;element div &gt; p 选择父元素是 &lt;div&gt; 的所有 &lt;p&gt; 元素。 element+element div + p 选择紧跟 &lt;div&gt; 元素的首个 &lt;p&gt; 元素。 element1~element2 p ~ ul 选择前面有 &lt;p&gt; 元素的每个 &lt;ul&gt; 元素。 attribute] [target] 选择带有 target 属性的所有元素。 attribute&#x3D;value] [target&#x3D;_blank] 选择带有 target&#x3D;”_blank” 属性的所有元素。 attribute~&#x3D;value] [title~&#x3D;flower] 选择 title 属性包含单词 “flower” 的所有元素。 attribute|&#x3D;value] [lang|&#x3D;en] 选择 lang 属性值以 “en” 开头的所有元素。 attribute^&#x3D;value] a[href^&#x3D;”https”] 选择其 src 属性值以 “https” 开头的每个 &lt;a&gt; 元素。 attribute$&#x3D;value] a[href$&#x3D;”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 &lt;a&gt; 元素。 attribute*&#x3D;value] a[href*&#x3D;”w3schools”] 选择其 href 属性值中包含 “abc” 子串的每个 &lt;a&gt; 元素。 :active a:active 选择活动链接。 ::after p::after 在每个 &lt;p&gt; 的内容之后插入内容。 ::before p::before 在每个 &lt;p&gt; 的内容之前插入内容。 :checked input:checked 选择每个被选中的 &lt;input&gt; 元素。 :default input:default 选择默认的 &lt;input&gt; 元素。 :disabled input:disabled 选择每个被禁用的 &lt;input&gt; 元素。 :empty p:empty 选择没有子元素的每个 &lt;p&gt; 元素（包括文本节点）。 :enabled input:enabled 选择每个启用的 &lt;input&gt; 元素。 :first-child p:first-child 选择属于父元素的第一个子元素的每个 &lt;p&gt; 元素。 ::first-letter p::first-letter 选择每个 &lt;p&gt; 元素的首字母。 ::first-line p::first-line 选择每个 &lt;p&gt; 元素的首行。 :first-of-type p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :focus input:focus 选择获得焦点的 &lt;input&gt; 元素。 :fullscreen :fullscreen 选择处于全屏模式的元素。 :hover a:hover 选择鼠标指针位于其上的链接。 :in-range input:in-range 选择其值在指定范围内的 &lt;input&gt; 元素。 :indeterminate input:indeterminate 选择处于不确定状态的 input 元素。 :invalid input:invalid 选择具有无效值的所有 &lt;input&gt; 元素。 :lang(language) p:lang(it) 选择 lang 属性等于 “it”（意大利）的每个 &lt;p&gt; 元素。 :last-child p:last-child 选择属于其父元素最后一个子元素每个 &lt;p&gt; 元素。 :last-of-type p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :link a:link 选择所有未访问过的链接。 :not(selector) :not(p) 选择非 &lt;p&gt; 元素的每个元素。 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 :only-of-type p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :only-child p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 :optional input:optional 选择不带 “required” 属性的 input 元素。 :out-of-range input:out-of-range 选择值超出指定范围的 input 元素。 ::placeholder input::placeholder 选择已规定 “placeholder” 属性的 input 元素。 :read-only input:read-only 选择已规定 “readonly” 属性的 input 元素。 :read-write input:read-write 选择未规定 “readonly” 属性的 input 元素。 :required input:required 选择已规定 “required” 属性的 input 元素。 :root :root 选择文档的根元素。 ::selection ::selection 选择用户已选取的元素部分。 :target #news:target 选择当前活动的 #news 元素。 :valid input:valid 选择带有有效值的所有 input 元素。 :visited a:visited 选择所有已访问的链接。 4. css 属性CSS 属性 用于控制网页的样式和布局。 css有很多css属性，要想把它们都学会，需要花费很长的时间。学习Java，我们不需要重点掌握。我们只需了解常用的css属性即可。 常用的css属性，可以参考这篇文章：CSS属性分类介绍 官方文档以上内容为简单了解与概括，若想了解更多可以浏览官方文档"},{"title":"HTML","path":"/wiki/JavaWeb/HTML.html","content":"1. 概述W3C标准规定了网页是由以下组成： 结构：HTML 表现：CSS 行为：JavaScript HTML(HyperText Markup Language)：超文本标记语言： 超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容 标记语言：由标签构成的语言。HTML中的标签都是预定义好的，运行在浏览器上并由浏览器解析，然后展示出对应的效果 2. 快速上手要实现一个html页面，我们需要从以下三步进行实现 新建文本文件，后缀名改为 .html 编写 HTML 结构标签 12345678&lt;html&gt;\t&lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; html标签是根标签， head 标签和 body 标签是html标签的两个子标签。而 head 标签的 title 子标签用来定义页面标题名称 body 标签的内容会被展示在内容区中 在&lt;body&gt;中定义文字 代码如下： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;html 快速上手&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;font color=&#x27;blue&#x27;&gt;hello html~&lt;/font&gt; &lt;/body&gt;&lt;/html&gt; 上述font 标签有一个 color 属性可以设置字体颜色，如： &lt;font color=&#39;blue&#39;&gt;&lt;/font&gt; 就是将文字设置成了红颜色。在网页中我们经常看到五颜六色的字体，我们就是通过标签属性color来实现。 3. 基础标签 标题标签: &lt;h1&gt; ~ &lt;h6&gt; , 共六级 标题标签中 h1最大，h6最小。 123456&lt;h1&gt;我是标题 h1&lt;/h1&gt;&lt;h2&gt;我是标题 h2&lt;/h2&gt;&lt;h3&gt;我是标题 h3&lt;/h3&gt;&lt;h4&gt;我是标题 h4&lt;/h4&gt;&lt;h5&gt;我是标题 h5&lt;/h5&gt;&lt;h6&gt;我是标题 h6&lt;/h6&gt; &lt;hr&gt;标签: 在浏览器中呈现出 横线 的效果。 1&lt;hr&gt; &lt;font&gt;字体标签 face 属性：用来设置字体。如 “楷体”、”黑体”等 color 属性：设置文字颜色。颜色有三种表示方式 英文单词：red,pink,blue… 表示的颜色特别有限，一般不用。 rgb(值1,值2,值3)：取值范围：0~255 三原色（红绿蓝）设置方式。 如： rgb(255,255,0)。书写起来麻烦，一般不用。 #值1值2值3：值的范围：00~FF, 十六进制写法 rgb方式的简化写法，基本都用此方式。值1表示红色的范围，值2表示绿色的范n，值3表示蓝色范围。如： #ff0000 size 属性：设置文字大小, 单位是 px 如： 1&lt;font face=&quot;楷体&quot; size=&quot;5&quot; color=&quot;#ff0000&quot;&gt;传智教育&lt;/font&gt; 注意：font 标签已经不建议使用了，以后如果要改变文字字体，大小，颜色可以使用 CSS 进行设置。 &lt;br&gt;换行标签 1&lt;br&gt; &lt;p&gt;段落标签 1&lt;p&gt;文本&lt;/p&gt; 加粗、斜体、下划线标签 b：加粗标签 i：斜体标签 u：下划线标签 123&lt;b&gt;文本1&lt;/b&gt;&lt;i&gt;文本2&lt;/i&gt;&lt;u&gt;文本3&lt;/u&gt; &lt;center&gt;居中标签: 文本居中 123&lt;center&gt; &lt;b&gt;沙柳河水流淌&lt;/b&gt;&lt;/center&gt;"},{"title":"HTTP","path":"/wiki/JavaWeb/HTTP.html","content":"1. HTTP介绍HyperText Transfer Protocol，超文本传输协议，是基于客户端&#x2F;服务端（C&#x2F;S）的架构模型，规定了浏览器和服务器之间数据传输的规则。 数据传输的规则指的是请求数据和响应数据需要按照指定的格式进行传输。 当我们在浏览器访问某个链接&#x2F;数据的时候，我们需要向服务器发送请求，请求需要有一定的格式才能被服务器所识别，然后才能正确返回我们所需要的数据。我们可以打开浏览器，点击F12打开开发者工具进入’网络&#x2F;network’查看请求格式，如图： 如看不到，可重新刷新页面获取请求资源 HTTP协议的特点: 基于TCP协议: 面向连接，安全 TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全。 基于请求-响应模型: 一次请求对应一次响应，请求和响应是一一对应关系, 简单理解就是一问一答模型。 无状态协议: 对于事物处理没有记忆能力。理解就是客户端发送HTTP请求给服务端之后，服务端根据请求返回响应数据，响应完后，不会记录任何信息。这种特性既有优点也有缺点: 缺点:多次请求间不能共享数据 优点:速度快 请求之间无法共享数据会引发的问题，如: 京东购物，’加入购物车’和’去购物车结算’是两次请求， HTTP协议的无状态特性，加入购物车请求响应结束后，未记录加入购物车是何商品 发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据 这个问题需要使用会话技术(Cookie、Session)来解决, 我们现在暂不了解。 2. 客户端请求消息客户端发送一个HTTP请求到服务器，请求消息总共分为三部分内容，分别是请求行、请求头、请求体。 请求行: 是HTTP请求中的第一行数据，请求行包含三块内容，分别是 GET[请求方式] /[请求URL路径] HTTP/1.1[HTTP协议及版本] HTTP 协议中共定义了九种方法或者叫’动作’来表明对 Request-URI 指定的资源的不同操作方式: HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。 HTTP1.1 新增六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。 序号 方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 我们在实际应用中常用的也就是 get 和 post，其他请求方式也都可以通过这两种方式间接的来实现。 请求头: 从第二行开始，格式为key: value形式 请求头中会包含若干个属性，常见的HTTP请求头有: 12345Host: 表示请求的主机名User-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko；Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有；Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。 请求头属性的作用:服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求，如: 不同浏览器解析HTML和CSS标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果 服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果 这就是我们常说的浏览器兼容问题 请求体: POST请求的最后一部分，存储请求参数 12345678910111213POST / HTTP/1.1Host: wengui.workCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.5304.107 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closename=zhangsan&amp;age=19 name=zhangsan&amp;age=19就是请求体的内容，请求体和请求头之间是有一个空行隔开。 3. 服务器响应消息响应消息总共分为三部分内容，分别是响应行、响应头、响应体 123456789101112131415HTTP/1.1 200 OKServer: openresty/1.21.4.1Date: Wed, 11 Jan 2023 12:39:14 GMTContent-Type: text/htmlConnection: closeX-Powered-By: Hexo&lt;html&gt; &lt;head&gt; &lt;title&gt;hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello &lt;/body&gt;&lt;/html&gt; 响应行: 响应数据的第一行,响应行包含三块内容，分别是 HTTP/1.1[HTTP协议及版本] 200[响应状态码] ok[状态码的描述] 响应头: 第二行开始，格式为key：value形式 响应头中会包含若干个属性，常见的HTTP响应头有: 123456Allow：服务器支持哪些请求方法（如GET、POST等）;Content-Type：表示该响应内容的类型，例如text/html，image/jpeg;Content-Length：表示该响应内容的长度（字节数）;Content-Encoding：表示该响应压缩算法，例如gzip;Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒Server：服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 响应体: 响应数据, 客户端请求的数据 &lt;html&gt;…&lt;&#x2F;html&gt;这部分内容就是响应体，它和响应头之间有一个空行隔开。 4. 状态码HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)： 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP状态码列表: 状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理"},{"title":"JavaWeb 概览","path":"/wiki/JavaWeb/index.html","content":"JavaWeb 知识库概览Java学习强化。目录概览："},{"title":"MySQL基础","path":"/wiki/JavaWeb/mysql基础.html","content":"1. 数据库相关概念以前我们做系统，数据持久化的存储采用的是文件存储。存储到文件中可以达到系统关闭数据不会丢失的效果，当然文件存储也有它的弊端。 假设在文件中存储以下的数据： 1234姓名\t年龄\t性别\t住址张三\t23\t男\t北京西三旗李四\t24\t女\t北京西二旗王五\t25\t男\t西安软件新城 现要修改李四这条数据的性别数据改为男，我们现学习的IO技术可以通过将所有的数据读取到内存中，然后进行修改再存到该文件中。通过这种方式操作存在很大问题，现在只有三条数据，如果文件中存储1T的数据，那么就会发现内存根本就存储不了。 现需要既能持久化存储数据，也要能避免上述问题的技术使用在我们的系统中。数据库就是这样的一门技术。 1.1 数据库 存储和管理数据的仓库，数据是有组织的进行存储。 数据库英文名是 DataBase，简称DB。 将数据存储在硬盘上，可以达到持久化存储的效果 1.2 数据库管理系统 管理数据库的大型软件 英文：DataBase Management System，简称 DBMS 安装了数据库管理系统后，就可以通过数据库管理系统创建数据库来存储数据，也可以通过该系统对数据库中的数据进行数据的增删改查相关的操作。我们平时说的MySQL数据库其实是MySQL数据库管理系统。 数据库管理系统示意图 1.3 常见的数据库管理系统常见数据库管理系统 简单介绍： Oracle：收费的大型数据库，Oracle 公司的产品 MySQL： 开源免费的中小型数据库。后来 Sun公司收购了 MySQL，而 Sun 公司又被 Oracle 收购 SQL Server：MicroSoft 公司收费的中型的数据库。C#、.net 等语言常使用 PostgreSQL：开源免费中小型的数据库 DB2：IBM 公司的大型收费数据库产品 SQLite：嵌入式的微型数据库。如：作为 Android 内置数据库 MariaDB：开源免费中小型的数据库 2. SQL概述2.1 SQL简介 英文：Structured Query Language，简称 SQL 结构化查询语言，一门操作关系型数据库的编程语言 定义操作所有关系型数据库的统一标准，可以使用SQL操作所有的关系型数据库管理系统，以后工作中如果使用到了其他的数据库管理系统，也同样的使用SQL来操作。 2.2 通用语法 SQL 语句可以单行或多行书写，以分号结尾。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 同样的一条sql语句写成下图的样子，一样可以运行处结果。 注释 单行注释: -- 注释内容 或 #注释内容(MySQL 特有) 注意：使用-- 添加单行注释时，--后面一定要加空格，而#没有要求。 多行注释: /* 注释内容 */ 2.3 SQL分类 DDL(Data Definition Language) ： 数据定义语言，用来定义数据库对象：数据库，表，列等 简单理解: 就是用来操作数据库，表等 DML(Data Manipulation Language) 数据操作语言，用来对数据库中表的数据进行增删改 简单理解: 对表中数据进行增删改 DQL(Data Query Language) 数据查询语言，用来查询数据库中表的记录(数据) 简单理解: 对数据进行查询操作。从数据库表中查询到我们想要的数据。 DCL(Data Control Language) 数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户 简单理解: 对数据库进行权限控制。比如我让某一个数据库表只能让某一个用户进行操作等。 注意： 我们最常操作的是 DML 和 DQL ，因为开发中最常操作的就是数据。 3. DDL:操作数据库操作数据库主要就是对数据库的增删查操作。 3.1 查询查询所有的数据库 1SHOW DATABASES; 3.2 创建数据库 创建数据库： 1CREATE DATABASE 数据库名称; 创建数据库(判断，如果不存在则创建) 1CREATE DATABASE IF NOT EXISTS 数据库名称; 3.3 删除数据库 删除数据库 1DROP DATABASE 数据库名称; 删除数据库(判断，如果存在则删除) 1DROP DATABASE IF EXISTS 数据库名称; 3.4 使用数据库 使用数据库 1USE 数据库名称; 查看当前使用的数据库 1SELECT DATABASE(); 4. DDL:操作表操作表也就是对表进行增（Create）删（Retrieve）改（Update）查（Delete）。 4.1 查询表 查询当前数据库下所有表名称 1SHOW TABLES; 查询表结构 1DESC 表名称; 4.2 创建表 创建表123456CREATE TABLE 表名 (\t字段名1 数据类型1,\t字段名2 数据类型2,\t…\t字段名n 数据类型n); 注意：最后一行末尾，不能加逗号 如： 12345create table user (\tid int, username varchar(20), password varchar(32)); 4.3 数据类型MySQL 支持多种类型，可以分为三类： 数值 123456tinyint : 小整数型，占一个字节int\t： 大整数类型，占四个字节\teg ： age intdouble ： 浮点类型\t使用格式： 字段名 double(总长度,小数点后保留的位数)\teg ： score double(5,2) 日期 123date ： 日期值。只包含年月日\teg ：birthday date ： datetime ： 混合日期和时间值。包含年月日时分秒 字符串 123456789char ： 定长字符串。\t优点：存储性能高\t缺点：浪费空间\teg ： name char(10) 如果存储的数据字符个数不足10个，也会占10个的空间\tvarchar ： 变长字符串。\t优点：节约空间\t缺点：存储性能底\teg ： name varchar(10) 如果存储的数据字符个数不足10个，那就数据字符个数是几就占几个的空间 4.4 删除表 删除表 1DROP TABLE 表名; 删除表时判断表是否存在 1DROP TABLE IF EXISTS 表名; 4.5 修改表 修改表名 1234ALTER TABLE 表名 RENAME TO 新的表名;-- 将表名student修改为stualter table student rename to stu; 添加一列 1234ALTER TABLE 表名 ADD 列名 数据类型;-- 给stu表添加一列address，该字段类型是varchar(50)alter table stu add address varchar(50); 修改数据类型 1234ALTER TABLE 表名 MODIFY 列名 新数据类型;-- 将stu表中的address字段的类型改为 char(50)alter table stu modify address char(50); 修改列名和数据类型 1234ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;-- 将stu表中的address字段名改为 addr，类型改为varchar(50)alter table stu change address addr varchar(50); 删除列 1234ALTER TABLE 表名 DROP 列名;-- 将stu表中的addr字段 删除alter table stu drop addr; 5. DMLDML主要是对数据进行增（insert）删（delete）改（update）操作。 5.1 添加数据 给指定列添加数据 1INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…); 给全部列添加数据 1INSERT INTO 表名 VALUES(值1,值2,…); 批量添加数据 12INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;INSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…; 练习 123456789101112-- 给指定列添加数据INSERT INTO stu (id, NAME) VALUES (1, &#x27;张三&#x27;);-- 给所有列添加数据，列名的列表可以省略的INSERT INTO stu (id,NAME,sex,birthday,score,email,tel,STATUS) VALUES (2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@qq.com&#x27;,&#x27;13888888888&#x27;,1);INSERT INTO stu VALUES (2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@qq.com&#x27;,&#x27;13888888888&#x27;,1);-- 批量添加数据INSERT INTO stu VALUES (2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@qq.com&#x27;,&#x27;13888888888&#x27;,1),\t(2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@qq.com&#x27;,&#x27;13888888888&#x27;,1),\t(2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@qq.com&#x27;,&#x27;13888888888&#x27;,1); 5.2 修改数据 修改表数据1UPDATE 表名 SET 列名1=值1,列名2=值2,… [WHERE 条件] ; 注意： 修改语句中如果不加条件，则将所有数据都修改！ 像上面的语句中的中括号，表示在写sql语句中可以省略这部分 练习 将张三的性别改为女 1update stu set sex = &#x27;女&#x27; where name = &#x27;张三&#x27;; 将张三的生日改为 1999-12-12 分数改为99.99 1update stu set birthday = &#x27;1999-12-12&#x27;, score = 99.99 where name = &#x27;张三&#x27;; 注意：如果update语句没有加where条件，则会将表中所有数据全部修改！ 1update stu set sex = &#x27;女&#x27;; 5.3 删除数据 删除数据 1DELETE FROM 表名 [WHERE 条件] ; 练习 12345-- 删除张三记录delete from stu where name = &#x27;张三&#x27;;-- 删除stu表中所有的数据delete from stu; 6. DQL数据库查询操作。 查询的完整语法： 1234567891011121314SELECT 字段列表FROM 表名列表 WHERE 条件列表GROUP BY 分组字段HAVING 分组后条件ORDER BY 排序字段LIMIT 分页限定 我们需要先准备表及一些数据： 123456789101112131415161718192021222324252627-- 删除stu表drop table if exists stu;-- 创建stu表CREATE TABLE stu ( id int, -- 编号 name varchar(20), -- 姓名 age int, -- 年龄 sex varchar(5), -- 性别 address varchar(100), -- 地址 math double(5,2), -- 数学成绩 english double(5,2), -- 英语成绩 hire_date date -- 入学时间);-- 添加数据INSERT INTO stu(id,NAME,age,sex,address,math,english,hire_date) VALUES (1,&#x27;马运&#x27;,55,&#x27;男&#x27;,&#x27;杭州&#x27;,66,78,&#x27;1995-09-01&#x27;),(2,&#x27;马花疼&#x27;,45,&#x27;女&#x27;,&#x27;深圳&#x27;,98,87,&#x27;1998-09-01&#x27;),(3,&#x27;马斯克&#x27;,55,&#x27;男&#x27;,&#x27;香港&#x27;,56,77,&#x27;1999-09-02&#x27;),(4,&#x27;柳白&#x27;,20,&#x27;女&#x27;,&#x27;湖南&#x27;,76,65,&#x27;1997-09-05&#x27;),(5,&#x27;柳青&#x27;,20,&#x27;男&#x27;,&#x27;湖南&#x27;,86,NULL,&#x27;1998-09-01&#x27;),(6,&#x27;刘德花&#x27;,57,&#x27;男&#x27;,&#x27;香港&#x27;,99,99,&#x27;1998-09-01&#x27;),(7,&#x27;张学右&#x27;,22,&#x27;女&#x27;,&#x27;香港&#x27;,99,99,&#x27;1998-09-01&#x27;),(8,&#x27;德玛西亚&#x27;,18,&#x27;男&#x27;,&#x27;南京&#x27;,56,65,&#x27;1994-09-02&#x27;); 6.1 基础查询6.1.1 语法 查询多个字段 12SELECT 字段列表 FROM 表名;SELECT * FROM 表名; -- 查询所有数据 去除重复记录 1SELECT DISTINCT 字段列表 FROM 表名; 起别名 1AS: AS 也可以省略 6.1.2 练习 查询name、age两列 1select name,age from stu; 查询所有列的数据，列名的列表可以使用*替代 1select * from stu; 查询地址信息 1select address from stu; ​ 去除重复记录 1select distinct address from stu; 查询姓名、数学成绩、英语成绩。并通过as给math和english起别名（as关键字可以省略） 12select name,math as 数学成绩,english as 英文成绩 from stu;select name,math 数学成绩,english 英文成绩 from stu; 6.2 条件查询6.2.1 语法 1SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件 条件列表可以使用以下运算符 运算符 6.2.2 条件查询练习 查询年龄大于20岁的学员信息 1select * from stu where age &gt; 20; 查询年龄大于等于20岁的学员信息 1select * from stu where age &gt;= 20; 查询年龄大于等于20岁 并且 年龄 小于等于 30岁 的学员信息 12select * from stu where age &gt;= 20 &amp;&amp; age &lt;= 30;select * from stu where age &gt;= 20 and age &lt;= 30; 上面语句中 &amp;&amp; 和 and 都表示并且的意思。建议使用 and 。 也可以使用 between … and 来实现上面需求 1select * from stu where age BETWEEN 20 and 30; 查询入学日期在’1998-09-01’ 到 ‘1999-09-01’ 之间的学员信息 1select * from stu where hire_date BETWEEN &#x27;1998-09-01&#x27; and &#x27;1999-09-01&#x27;; 查询年龄等于18岁的学员信息 1select * from stu where age = 18; 查询年龄不等于18岁的学员信息 12select * from stu where age != 18;select * from stu where age &lt;&gt; 18; 查询年龄等于18岁 或者 年龄等于20岁 或者 年龄等于22岁的学员信息 12select * from stu where age = 18 or age = 20 or age = 22;select * from stu where age in (18,20 ,22); 查询英语成绩为 null的学员信息 null值的比较不能使用 &#x3D; 或者 !&#x3D; 。需要使用 is 或者 is not 123select * from stu where english = null; -- 这个语句是不行的select * from stu where english is null;select * from stu where english is not null; 6.2.3 模糊查询练习 模糊查询使用like关键字，可以使用通配符进行占位: （1）_ : 代表单个任意字符 （2）% : 代表任意个数字符 查询姓’贵’的学员信息 1select * from stu where name like &#x27;贵%&#x27;; 查询第二个字是’贵’的学员信息 1select * from stu where name like &#x27;_贵%&#x27;; 查询名字中包含 ‘贵’ 的学员信息 1select * from stu where name like &#x27;%贵%&#x27;; 6.3 排序查询6.3.1 语法 1SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …; 上述语句中的排序方式有两种，分别是： ASC ： 升序排列 （默认值） DESC ： 降序排列 注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序 6.3.2 练习 查询学生信息，按照年龄升序排列 1select * from stu order by age ; 查询学生信息，按照数学成绩降序排列 1select * from stu order by math desc ; 查询学生信息，按照数学成绩降序排列，如果数学成绩一样，再按照英语成绩升序排列 1select * from stu order by math desc , english asc ; 6.4 聚合函数6.4.1 概念 将一列数据作为一个整体，进行纵向计算。 假设有如下表 6.4.2 聚合函数分类 函数名 功能 count(列名) 统计数量（一般选用不为null的列） max(列名) 最大值 min(列名) 最小值 sum(列名) 求和 avg(列名) 平均值 6.4.3 聚合函数语法 1SELECT 聚合函数名(列名) FROM 表; 注意：null 值不参与所有聚合函数运算 6.4.4 练习 统计班级一共有多少个学生 12select count(id) from stu;select count(english) from stu; 上面语句根据某个字段进行统计，如果该字段某一行的值为null的话，将不会被统计。所以可以在count(*) 来实现。* 表示所有字段数据，一行中也不可能所有的数据都为null，所以建议使用 count(*) 1select count(*) from stu; 查询数学成绩的最高分 1select max(math) from stu; 查询数学成绩的最低分 1select min(math) from stu; 查询数学成绩的总分 1select sum(math) from stu; 查询数学成绩的平均分 1select avg(math) from stu; 查询英语成绩的最低分 1select min(english) from stu; 6.5 分组查询6.5.1 语法 1SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤]; 注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义 6.5.2 练习 查询男同学和女同学各自的数学平均分 1select sex, avg(math) from stu group by sex; 注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义 1select name, sex, avg(math) from stu group by sex; -- 这里查询name字段就没有任何意义 查询男同学和女同学各自的数学平均分，以及各自人数 1select sex, avg(math),count(*) from stu group by sex; 查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组 1select sex, avg(math),count(*) from stu where math &gt; 70 group by sex; 查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组，分组之后人数大于2个的 1select sex, avg(math),count(*) from stu where math &gt; 70 group by sex having count(*) &gt; 2; where 和 having 区别： 执行时机不一样：where 是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。 可判断的条件不一样：where 不能对聚合函数进行判断，having 可以。 6.6 分页查询6.6.1 语法 1SELECT 字段列表 FROM 表名 LIMIT 起始索引 , 查询条目数; 注意： 上述语句中的起始索引是从0开始 6.6.2 练习 从0开始查询，查询3条数据 1select * from stu limit 0 , 3; 每页显示3条数据，查询第1页数据 1select * from stu limit 0 , 3; 每页显示3条数据，查询第2页数据 1select * from stu limit 3 , 3; 起始索引计算公式： 1起始索引 = (当前页码 - 1) * 每页显示的条数"}]